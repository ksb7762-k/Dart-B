## 6-1. 이번 파트에서 다룰 내용 

- 가독성을 챙기기 위한 SQL 스타일 가이드 
- 데이터 결고 검증
- 데이터 결과 검증 예시 

## 6-2 가독성을 챙기기 위한 SQL 스타일 가이드 
데이터 결과 검증을 하기 전에 실수는 언제 발생하는가?
- 문법을 잘못 알고 있는 경우
- 테이터를 잘못 알고 있는 경우
- 데이터를 파악하지 않고 쿼리를 작성하는 경우
- 쿼리가 복잡한 경우 

## 1. 예약어는 대문자로 작성
SQL에서 문법적인 용도로 사용하고 있는 문자들은 대문자로 작성  

**예약어의 대표적인 예시 : SELECT, FROM, WHERE, 각종 함수**

## 2. 컬럼 이름은 snake_case로 작성

컬럼 이름은 CamelCase가 아닌, **snake_case (언더바)** 로 작성 
(단, 회사의 기준이 CamelCase면 사용, 일관성이 중요)  

## 3. 명시적 vs 암시적인 이름

Alias로 별칭을 지을 때는 명시적인 이름을 적용  

AS a, AS b 등 컬럼의 의미를 한번 더 생각하게 하는 이름이 아닌 명시적인 것을 사용  

JOIN 할 때 테이블의 이름도 명시적으로 할 수 있다면 명시적으로 진행하기  

AS를 생략해서 별칭을 설정할 수도 있는데, AS를 쓰는 것도 명시적인 표현 

## 4. 왼쪽 정렬  

기본적으로 왼쪽 정렬을 기준으로 작성 

## 5. 예약어나 컬럼은 한 줄에 하나씩 권장  

컬럼은 바로 주석처리할 수 있는 장점이 있기에 한 줄에 하나씩 작성  

## 6. 쉼표는 컬럼 바로 뒤에 

의견이 갈리는 부분 (쉼표 앞 vs 뒤)  

BigQuery는 마지막 쉼표를 무시해서 뒤에 작성해도 무방 

## 6-3. 가독성을 챙기기 위한 WITH문 & 파티션  

## WITH 구문 

SQL 쿼리를 작성하다 생기는 일 => 점점 복잡해짐 (가독성 하락)  
- **만약 아래 쿼리가 다른 곳에서도 필요하면 복사 붙여넣기**
  
WITH 문을 사용해 쿼리를 정의해서 재사용 가능  

![](/image_SQL/7-1.PNG)  

  

- CTE(Common Table Expression)라고 표현 
- SELECT 구문에 이름을 정해주는 것과 유사  
- 쿼리 내에서 반복적으로 사용할 수 있음  

## PARTITION  
Table엔 Partition이란 것이 존재할 수 있음  

예시)  
창고에 수많은 물건이 매일 많으 들어옴  
특정시기에 들어온 물건을 찾고 싶다면?  
애초에 일자별로 정리하면 됨 


![](/image_SQL/7-2.PNG)  

## PARTITION을 사용하면 좋은 점
1. 쿼리 성능 향상 
- 전체 데이터를 스캔하는 것보다 파티션을 설정한 곳만 스캔하는 것이 더 빠름 
2. 데이터 관리 용이성
- 특정 일자의 데이터를 모두 변경하거나 삭제해야 하면 파티션을 설정해서 삭제할 수 있음 
3. 비용 
- 파티션에 해당되는 데이터만 스캔해서 비용을 줄일 수 있음
(BigQuery는 쿼리 용량에 비례해서 과금)  


## PARTITION Table : battle   

다음과 같은 형태가 생성됨    

이를 조금 더 보기 좋게 가공 


![](/image_SQL/7-3.PNG)  


WHERE 절에 파티션 컬럼에 대해 조건을 설정해서 사용  

아래 쿼리는 '2023-12-19'부터 하루 전날의 데이터를 추출하는 쿼리(저장된 데이터는 더 과거 데이터라 이 쿼리를 돌릴 때 결과는 나오지 않음)  


![](/image_SQL/7-4.PNG)  




![](/image_SQL/7-5.PNG)  


## 6-4. 데이터 결과 검증 (Data Result Validation) 정의  

SQL쿼리 후 얻은 결과가 예상과 일치하는지 확인하는 과정  

목적 : 분석 결과의 정확성, 신뢰성 확보  

방법은 심플 
- 내가 기대하는 예상 결과를 정의
- 쿼리 작성
- 두개가 일치하는지 비교  

제일 중요한 부분 
- **문제를 잘 정의하고, 미리 작성해보기**
- **도메인 특수성(이런 규칙 등) 잘 파악하기**
- SQL 쿼리 템플릿과 맥락이 유사  

## 데이터 결과를 검증하는 흐름  

1. 문제 정의 확인
- 구체적인 문제 정의, 요청 사항도 구체적으로 확인 
2. Input/Output 
- 데이터의 Input과 (원하는 형태의) Output 작성하기 
- Input - (중간 결과) - Output에서 중간 결과 생각하기 
3. 쿼리 작성 
- **가독성 챙기기**
4. 결과 비교 
- 예상과 실제 쿼리 결과의 차이가 있는지 확인 
- 오류가 있다면 **다시 쿼리 작성**
- 오류가 없다면 **끝**  

## 데이터 결과 검증할 때 자주 활용하는 SQL 쿼리 

대표적으로 활용하는 SQL 문법

1. COUNT(*) : 행 수를 확인. 의도한 데이터의 행 개수가 맞는가?
2. NOT NULL : 특정 컬럼에 NULL이 존재하는가? 필수 필드가 비어있지 않은가? (데이터가 잘 저장되어 있는가?)
3. DISTINCT : 데이터의 고유값을 확인해 중복 여부 확인 (COUNT(DISTINCT 컬럼)) = COUNT(컬럼)  

4. IF문, CASE WHEN : 의도와 같다면 TRUE 아니면 FALSE 

## 6-5 데이터 결과 검증 에시

### 데이터 결과 검증 예시 문제 

 여러분은 포켓몬 트레이너들의 배틀 성적을 분석하는 작업을 맡게 되었습니다.  

 각 트레이너가 진행한 배틀의 승리 비울을 계산해야 하며, 배틀에 참여한 횟수가 9회 이상인 경우만 계산합니다.  

1) **전체 데이터 파악** 
 파악할 테이블 : battle 테이블  

  

![](/image_SQL/7-7.PNG)  


2) **특정 user_id 선정**

특정 user_id(battle에선 playerN_id)를 선정  

회사에선 자신의 user_id를 사용하지만, 여기선 임의로  **7** 선택  




![](/image_SQL/7-8.PNG)  


player1_id에 있을 수도 있고 player2_id에 있을 수도 있음을 확인!  



![](/image_SQL/7-9.PNG)  


3) 승률 직접 COUNT : 결과 예상  



![](/image_SQL/7-10.PNG)  


4) 쿼리 작성
- 트레이너가 승리한 비율 구하기 
- 트레이너가 참여한 배틀의 수 구하기 -> 9
- 트레이너가 승리한 배틀의 수 구하기  -> 5
- 두개 조합해서 승리한 비율 구할 수 있음  -> 5/9 
- 단, 이 쿼리를 어떻게 해야할까? 쉽게 가능할까?
- 배틀의 수가 9 이상만 추출
- (예상 정답) player_id = 7의 승리한 비율은 0.55556이 나와야 함  

  
통합 데이터 생성 ( player1,2 구분을 하지 않아도 되는 테이블 => trainer_id 생성)  

trainer_id = 7의 총 배틀 횟수를 구하는 쿼리   


![](/image_SQL/7-11.PNG)  



trainer_id와 winner_id를 조합해서 WIN, LOSE, DRAW를 만들어보면 어떨까?  



![](/image_SQL/7-12.PNG)  


5) 실제와 비교   

COUNTIF를 사용해 값 구하기 

6) 맞다면 특정 유저 조건 제외  

WHERE의 trainer_id 제거 후, 총 배틀 횟수가 9 이상만 조건    












 



